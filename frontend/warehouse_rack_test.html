<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Warehouse 3D</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <script type="importmap">
  {
    "imports": {
      "three": "/js/build/three.module.js",
      "three/examples/jsm/": "/js/examples/jsm/"
    }
  }
  </script>

  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
    }
    #viewport {
      background: #020617;
    }
  </style>
</head>
<body class="bg-gray-900 text-white">

<div class="flex h-screen w-screen overflow-hidden">

  <div class="w-80 bg-gray-800 p-5 space-y-4 overflow-y-auto">
    <h1 class="text-2xl font-bold mb-2">Warehouse 3D</h1>

    <div>
      <label class="block text-sm mb-1">Warehouse åˆ‡æ›</label>
      <select id="warehouseSelect"
              class="w-full bg-gray-700 p-2 rounded outline-none">
        <option value="WH1">WH1</option>
        <option value="WH2">WH2</option>
        <option value="WH3">WH3</option>
        <option value="WH5">WH5</option>
        <option value="WH6">WH6</option>
        <option value="WH7">WH7</option>
        <option value="WH8">WH8</option>
      </select>
    </div>

    <div>
      <label class="block text-sm mb-1">Row æ•¸</label>
      <input id="rowsInput" type="number" value="12" min="1"
             class="w-full bg-gray-700 p-2 rounded outline-none" />
    </div>

    <div>
      <label class="block text-sm mb-1">Bay æ•¸</label>
      <input id="baysInput" type="number" value="50" min="1"
             class="w-full bg-gray-700 p-2 rounded outline-none" />
    </div>

    <div>
      <label class="block text-sm mb-1">Level æ•¸</label>
      <input id="levelsInput" type="number" value="5" min="1"
             class="w-full bg-gray-700 p-2 rounded outline-none" />
    </div>

    <div>
      <label class="block text-sm mb-1">Aisleï¼ˆèµ°é“å¯¬ï¼Œå…¬å°ºï¼‰</label>
      <input id="aisleInput" type="number" value="3.5" step="0.1" min="1"
             class="w-full bg-gray-700 p-2 rounded outline-none" />
    </div>

    <button id="rebuild"
            class="w-full bg-blue-600 hover:bg-blue-500 p-2 rounded font-semibold">
      Rebuild 3D
    </button>

    <button id="random"
            class="w-full bg-indigo-600 hover:bg-indigo-500 p-2 rounded font-semibold">
      Random Fillï¼ˆDemoï¼‰
    </button>

    <button id="syncExcel"
            class="w-full bg-green-600 hover:bg-green-500 p-2 rounded font-semibold">
      Sync Excel
    </button>

    <button id="exportExcel"
            class="w-full bg-yellow-500 hover:bg-yellow-400 text-black p-2 rounded font-semibold">
      Export Excel
    </button>

    <div>
      <label class="block text-sm mb-1">æœå°‹å„²ä½ï¼ˆä¾‹å¦‚ï¼šF-19-04 æˆ– F1904ï¼‰</label>
      <input id="searchSlot" type="text"
             class="w-full bg-gray-700 p-2 rounded outline-none"
             placeholder="ä¾‹å¦‚ F-19-04 / F1904" />
      <button id="searchBtn"
              class="w-full bg-orange-600 hover:bg-orange-500 p-2 rounded font-semibold mt-2">
        Search
      </button>
    </div>

    <p class="text-xs text-gray-400 mt-4 leading-relaxed">
      å·¦éµé»å„²ä½çœ‹è³‡è¨Šã€‚å³éµå¹³ç§»ã€‚æ»¾è¼ªç¸®æ”¾ã€‚<br><br>
      WebSocketï¼š<span class="font-mono">/ws/{warehouse}</span><br>
      APIï¼š<span class="font-mono">/api/{warehouse}/excel</span><br><br>
      åˆ°æœŸæ—¥ â‰¦ ä»Šæ—¥ â†’ ç´…ç®±ï¼‹ç™½æ¡†ï¼‹åŠ‡çƒˆæ™ƒå‹•<br>
      30 å¤©å…§ â†’ ç™½ç®±ï¼‹ç´…æ¡†ï¼‹å°å¹…è·³å‹•
    </p>

    <div id="importTime" class="text-xs text-gray-400">
      æœ€å¾ŒåŒ¯å…¥æ™‚é–“ï¼šå°šæœªåŒ¯å…¥
    </div>

    <div id="slotInfo"
         class="bg-gray-700 mt-3 p-3 rounded min-h-[120px] text-sm leading-relaxed">
      è«‹é»é¸å„²ä½æˆ–åŒ¯å…¥ Excelã€‚
    </div>
  </div>

  <div id="viewport" class="flex-1"></div>

</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

const API_BASE = "https://warehouse-3d-python-api.onrender.com";
const WS_BASE = "wss://warehouse-3d-websocket.onrender.com";

let currentWarehouse = "WH1";
let ws = null;

function connectWS() {
    const url = `${WS_BASE}/ws/${currentWarehouse}`;
    ws = new WebSocket(url);

    ws.onopen = () => {};
    ws.onclose = () => {
        setTimeout(connectWS, 5000);
    };
    ws.onerror = () => {};
    ws.onmessage = (msg) => {
        const data = JSON.parse(msg.data);
        if (data.type === "update") {
            logicalSlots.clear();
            for (const slot of data.slots) {
                const key = `${slot.row}_${slot.bay}_${slot.level}`;
                logicalSlots.set(key, slot);
            }
            applyLogicalSlotsToBins();
            slotInfoEl.textContent = `å·²å¥—ç”¨ ${currentWarehouse} æœ€æ–° Excel æ›´æ–°`;
        }
    };
}

connectWS();

async function fetchExcelFromAPI() {
    try {
        const url = `${API_BASE}/api/${currentWarehouse}/excel`;
        const resp = await fetch(url);
        if (!resp.ok) {
            alert(`ç„¡æ³•è®€å– ${currentWarehouse} Excel`);
            return null;
        }
        return await resp.arrayBuffer();
    } catch (_) {
        alert("è®€å– Excel æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼ŒPython API å¯èƒ½æœªå•Ÿå‹•");
        return null;
    }
}

async function syncFromExcelAPI() {
    const buf = await fetchExcelFromAPI();
    if (!buf) return;

    const wb = XLSX.read(buf, { type: "array" });
    const sheet = wb.Sheets[wb.SheetNames[0]];
    const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });

    const header = rows[0] || [];
    const idxRow = header.indexOf("Row");
    const idxBay = header.indexOf("Bay");
    const idxLvl = header.indexOf("Level");
    const idxOcc = header.indexOf("Occupied");
    const idxPN = header.indexOf("PN");
    const idxQty = header.indexOf("æ•¸é‡");
    const idxBat = header.indexOf("Batch");
    const idxExp = header.indexOf("Expire Date");
    const idxMfg = header.indexOf("Manufacture Date");

    logicalSlots.clear();

    for (let i = 1; i < rows.length; i++) {
        const row = rows[i];
        if (!row) continue;

        const rIndex = rowLabelToIndex(row[idxRow]);
        const bIndex = parseInt(row[idxBay]) - 1;
        const lvIndex = parseInt(row[idxLvl]) - 1;

        const occ = row[idxOcc] == 1;

        const expDate = excelToDate(row[idxExp]);
        const expStatus = classifyExpiry(expDate);

        const meta = {
            "PN": row[idxPN] ?? "",
            "æ•¸é‡": row[idxQty] ?? "",
            "Batch": row[idxBat] ?? "",
            "Expire Date": row[idxExp] ?? "",
            "Manufacture Date": row[idxMfg] ?? ""
        };

        const key = `${rIndex}_${bIndex}_${lvIndex}`;

        logicalSlots.set(key, {
            row: rIndex,
            bay: bIndex,
            level: lvIndex,
            occupied: occ,
            meta,
            expStatus,
            expDateISO: expDate ? expDate.toISOString().slice(0, 10) : null
        });
    }

    applyLogicalSlotsToBins();

    const t = new Date().toLocaleString();
    importTimeEl.textContent = `æœ€å¾ŒåŒ¯å…¥æ™‚é–“ï¼ˆ${currentWarehouse}ï¼‰ï¼š${t}`;
    slotInfoEl.textContent = `Excel å·²åŒæ­¥ï¼š${currentWarehouse}`;
}

const warehouseSelect = document.getElementById("warehouseSelect");

warehouseSelect.addEventListener("change", async () => {
    currentWarehouse = warehouseSelect.value;
    try { ws.close(); } catch (_) {}
    setTimeout(connectWS, 300);
    await syncFromExcelAPI();
    slotInfoEl.textContent = `å·²åˆ‡æ›åˆ° ${currentWarehouse}`;
});
const viewport = document.getElementById('viewport');
const slotInfoEl = document.getElementById('slotInfo');
const importTimeEl = document.getElementById('importTime');

const ui = {
    rows: document.getElementById('rowsInput'),
    bays: document.getElementById('baysInput'),
    levels: document.getElementById('levelsInput'),
    aisle: document.getElementById('aisleInput'),
    rebuildBtn: document.getElementById('rebuild'),
    randomBtn: document.getElementById('random'),
    syncExcelBtn: document.getElementById('syncExcel'),
    exportExcelBtn: document.getElementById('exportExcel'),
    searchSlot: document.getElementById('searchSlot'),
    searchBtn: document.getElementById('searchBtn')
};

const ROW_LABELS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
function rowIndexToLabel(i){ return ROW_LABELS[i] || String(i); }
function rowLabelToIndex(v){
    const s = String(v).trim().toUpperCase();
    if (s.length === 1 && ROW_LABELS.includes(s)) return ROW_LABELS.indexOf(s);
    const n = Number(s);
    return Number.isFinite(n) ? n : null;
}
function bayIndexToNumber(i){ return i + 1; }
function levelIndexToNumber(i){ return i + 1; }
function pad2(n){ return String(n).padStart(2,'0'); }
function slotKey(r,b,l){ return `${r}_${b}_${l}`; }

const renderer = new THREE.WebGLRenderer({ antialias:true });
function getSize(){
    const w = viewport.clientWidth || window.innerWidth;
    const h = viewport.clientHeight || window.innerHeight;
    return { w, h };
}
const size0 = getSize();
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(size0.w, size0.h);
viewport.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x020617);

const camera = new THREE.PerspectiveCamera(50, size0.w/size0.h, 0.1, 4000);
camera.position.set(30, 25, 40);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.target.set(0, 4, 0);
controls.update();

scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const dir = new THREE.DirectionalLight(0xffffff, 0.8);
dir.position.set(-30, 40, 20);
scene.add(dir);

const gridBase = new THREE.GridHelper(600, 60, 0x22c55e, 0x1e293b);
gridBase.position.y = 0;
scene.add(gridBase);

const gridRoute = new THREE.GridHelper(200, 40, 0x0ea5e9, 0x0f172a);
gridRoute.position.y = 0.02;
gridRoute.material.transparent = true;
gridRoute.material.opacity = 0.35;
scene.add(gridRoute);

const originCube = new THREE.Mesh(
    new THREE.BoxGeometry(0.6,0.6,0.6),
    new THREE.MeshStandardMaterial({ color:0xeab308 })
);
originCube.position.set(0,0.3,0);
scene.add(originCube);

let warehouseGroup = new THREE.Group();
scene.add(warehouseGroup);

const raycaster = new THREE.Raycaster();
const clock = new THREE.Clock();

const clickTargets = [];
const bins = [];
const logicalSlots = new Map();

let highlightedBin = null;
let highlightEndTime = 0;

const BIN_W = 1.10;
const BIN_H = 1.40;
const BIN_D = 1.20;
const BAY_GAP_X = 0.20;
const ROW_EXTRA = 0.40;

const COLORS = {
    wireNormal:    0x4b5563,
    cargoNormal:   0xc49a6c,
    wireNear:      0xef4444,
    cargoNear:     0xffffff,
    wireExpired:   0xffffff,
    cargoExpired:  0xef4444,
    wireHighlight: 0x22c55e
};

function makeWireBox(w,h,d){
    const geo = new THREE.EdgesGeometry(new THREE.BoxGeometry(w,h,d));
    const mat = new THREE.LineBasicMaterial({ color: COLORS.wireNormal, transparent:true, opacity:0.5 });
    return new THREE.LineSegments(geo, mat);
}

function makeHitBox(w,h,d){
    const geo = new THREE.BoxGeometry(w,h,d);
    const mat = new THREE.MeshBasicMaterial({ transparent:true, opacity:0.0, depthWrite:false });
    return new THREE.Mesh(geo, mat);
}

function makeCargo(w,h,d){
    const geo = new THREE.BoxGeometry(w*0.94, Math.min(h*0.9, 1.2), d*0.94);
    const mat = new THREE.MeshStandardMaterial({ color: COLORS.cargoNormal, roughness:0.85, metalness:0 });
    const m = new THREE.Mesh(geo, mat);
    m.visible = false;
    return m;
}

function clearWarehouse(){
    scene.remove(warehouseGroup);
    warehouseGroup.traverse(o=>{
        if (o.geometry) o.geometry.dispose();
        if (o.material){
            if (Array.isArray(o.material)) o.material.forEach(m=>m.dispose());
            else o.material.dispose();
        }
    });
    warehouseGroup = new THREE.Group();
    scene.add(warehouseGroup);
    clickTargets.length = 0;
    bins.length = 0;
}

function rebuild(){
    const rows   = Math.max(1, parseInt(ui.rows.value)   || 1);
    const bays   = Math.max(1, parseInt(ui.bays.value)   || 1);
    const levels = Math.max(1, parseInt(ui.levels.value) || 1);
    const aisle  = Math.max(1, parseFloat(ui.aisle.value)|| 1);

    clearWarehouse();

    const baySpacing = BIN_W + BAY_GAP_X;
    const rowSpacing = BIN_D + ROW_EXTRA + aisle;

    const totalW = bays * baySpacing - BAY_GAP_X;
    const totalD = rows * rowSpacing - aisle;

    const x0 = -totalW/2 + BIN_W/2;
    const z0 = -totalD/2 + BIN_D/2;

    for (let r=0; r<rows; r++){
        const z = z0 + r*rowSpacing;
        for (let b=0; b<bays; b++){
            const x = x0 + b*baySpacing;
            for (let lv=0; lv<levels; lv++){
                const y = 0.05 + lv*BIN_H + BIN_H/2;

                const wire  = makeWireBox(BIN_W,BIN_H,BIN_D); wire.position.set(x,y,z);
                const hit   = makeHitBox(BIN_W,BIN_H,BIN_D);  hit.position.set(x,y,z);
                const cargo = makeCargo(BIN_W,BIN_H,BIN_D);   cargo.position.set(x,y,z);

                warehouseGroup.add(wire, hit, cargo);

                const rec = {
                    row: r,
                    bay: b,
                    level: lv,
                    line: wire,
                    hit,
                    cargo,
                    occupied: false,
                    meta: null,
                    expStatus: 'ok',
                    baseX: x,
                    baseY: y,
                    baseZ: z
                };
                bins.push(rec);
                hit.userData.bin = rec;
                clickTargets.push(hit);
            }
        }
    }

    fitCameraToObject(warehouseGroup);
    slotInfoEl.textContent = 'å·²é‡å»º 3D åœ–é¢ã€‚';

    applyLogicalSlotsToBins();
}

function setOccupied(bin, occ){
    bin.occupied = !!occ;
    bin.cargo.visible = !!occ;
}

function applyLogicalSlotsToBins(){
    for (const bin of bins){
        const key = slotKey(bin.row, bin.bay, bin.level);
        const slot = logicalSlots.get(key);
        if (slot){
            bin.meta      = slot.meta || null;
            bin.expStatus = slot.expStatus || 'ok';
            setOccupied(bin, slot.occupied);
        }else{
            bin.meta      = null;
            bin.expStatus = 'ok';
            setOccupied(bin, false);
        }
    }
}

function randomFill(){
    logicalSlots.clear();
    for (const bin of bins){
        const occ = Math.random() < 0.35;
        setOccupied(bin, occ);
        if (occ){
            bin.meta = null;
            bin.expStatus = 'ok';
            const key = slotKey(bin.row, bin.bay, bin.level);
            logicalSlots.set(key, {
                row: bin.row,
                bay: bin.bay,
                level: bin.level,
                occupied: true,
                meta: null,
                expStatus: 'ok',
                expDateISO: null
            });
        }
    }
    slotInfoEl.textContent = 'Random Fill å®Œæˆï¼ˆç¤ºæ„ç”¨ï¼Œä¸å«å¯¦éš›è²¨ç‰©è³‡è¨Šï¼‰ã€‚';
}

function fitCameraToObject(object){
    const box = new THREE.Box3().setFromObject(object);
    const size = box.getSize(new THREE.Vector3());
    const center = box.getCenter(new THREE.Vector3());
    const maxDim = Math.max(size.x,size.y,size.z);
    const fov = camera.fov * Math.PI/180;
    let dist = (maxDim/2)/Math.tan(fov/2);
    dist *= 1.3;
    camera.position.set(center.x + dist*0.9,
                        center.y + dist*0.7,
                        center.z + dist*0.9);
    controls.target.copy(center);
    controls.update();
}

renderer.setAnimationLoop(()=>{
    const t = clock.getElapsedTime();
    const ampNear   = 0.08;
    const speedNear = 4.0;
    const ampExpPos   = 0.45;
    const ampExpY     = 0.40;
    const speedExpPos = 15.0;
    const nowT = t;

    for (const bin of bins){
        const lineMat  = bin.line.material;
        const cargoMat = bin.cargo.material;

        bin.cargo.position.set(bin.baseX, bin.baseY, bin.baseZ);

        let wireColor  = COLORS.wireNormal;
        let cargoColor = COLORS.cargoNormal;
        let opacity    = 0.45;

        if (bin.occupied){
            if (bin.expStatus === 'near'){
                wireColor  = COLORS.wireNear;
                cargoColor = COLORS.cargoNear;
                bin.cargo.position.y =
                    bin.baseY + Math.sin(t * speedNear) * ampNear;
                opacity = 0.9;
            }else if (bin.expStatus === 'expired'){
                wireColor  = COLORS.wireExpired;
                cargoColor = COLORS.cargoExpired;

                const phase = (bin.row * 7 + bin.bay * 13 + bin.level * 17);

                bin.cargo.position.x =
                    bin.baseX + Math.sin(t * speedExpPos + phase) * ampExpPos;
                bin.cargo.position.z =
                    bin.baseZ + Math.cos(t * speedExpPos + phase) * ampExpPos;
                bin.cargo.position.y =
                    bin.baseY + Math.sin(t * speedExpPos * 0.7 + phase) * ampExpY;

                const flash = 0.40 + 0.45 * (0.5 + 0.5 * Math.sin(t * 12 + phase));
                opacity = flash;
            }else{
                wireColor  = COLORS.wireNormal;
                cargoColor = COLORS.cargoNormal;
                opacity = 0.7;
            }
        }

        if (bin === highlightedBin && nowT < highlightEndTime){
            wireColor = COLORS.wireHighlight;
            opacity   = 1.0;
        }

        lineMat.color.setHex(wireColor);
        lineMat.opacity = opacity;
        cargoMat.color.setHex(cargoColor);
    }

    controls.update();
    renderer.render(scene, camera);
});

function excelToDate(value){
    if (value == null || value === '') return null;
    if (typeof value === 'number'){
        const base = new Date(Date.UTC(1899,11,30));
        const d = new Date(base.getTime() + value * 86400000);
        return d;
    }
    if (typeof value === 'string'){
        const s = value.trim();
        if (!s) return null;
        const m = s.match(/^(\d{4})[\/\-]?(\d{2})[\/\-]?(\d{2})$/);
        if (m){
            const y = parseInt(m[1],10);
            const mo= parseInt(m[2],10)-1;
            const da= parseInt(m[3],10);
            return new Date(y,mo,da);
        }
        const d = new Date(s);
        if (!isNaN(d.getTime())) return d;
    }
    return null;
}

function classifyExpiry(expDate){
    if (!expDate) return 'ok';
    const today = new Date();
    const baseToday = new Date(today.getFullYear(), today.getMonth(), today.getDate());
    const baseExp   = new Date(expDate.getFullYear(), expDate.getMonth(), expDate.getDate());
    const diffDays = (baseExp - baseToday)/86400000;
    if (diffDays < 0) return 'expired';
    if (diffDays <= 30) return 'near';
    return 'ok';
}

async function syncFromExcelAPI(){
    const buf = await fetchExcelFromAPI();
    if (!buf) return;

    const wb = XLSX.read(buf, { type: "array" });
    const sheet = wb.Sheets[wb.SheetNames[0]];
    const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });

    const header = rows[0] || [];
    const idxRow = header.indexOf("Row");
    const idxBay = header.indexOf("Bay");
    const idxLvl = header.indexOf("Level");
    const idxOcc = header.indexOf("Occupied");
    const idxPN = header.indexOf("PN");
    const idxQty = header.indexOf("æ•¸é‡");
    const idxBat = header.indexOf("Batch");
    const idxExp = header.indexOf("Expire Date");
    const idxMfg = header.indexOf("Manufacture Date");

    logicalSlots.clear();

    for (let i = 1; i < rows.length; i++) {
        const row = rows[i];
        if (!row) continue;

        const rIndex = rowLabelToIndex(row[idxRow]);
        const bIndex = parseInt(row[idxBay]) - 1;
        const lvIndex = parseInt(row[idxLvl]) - 1;

        const occ = row[idxOcc] == 1;

        const expDate = excelToDate(row[idxExp]);
        const expStatus = classifyExpiry(expDate);

        const meta = {
            "PN": row[idxPN] ?? "",
            "æ•¸é‡": row[idxQty] ?? "",
            "Batch": row[idxBat] ?? "",
            "Expire Date": row[idxExp] ?? "",
            "Manufacture Date": row[idxMfg] ?? ""
        };

        const key = `${rIndex}_${bIndex}_${lvIndex}`;

        logicalSlots.set(key, {
            row: rIndex,
            bay: bIndex,
            level: lvIndex,
            occupied: occ,
            meta,
            expStatus,
            expDateISO: expDate ? expDate.toISOString().slice(0, 10) : null
        });
    }

    applyLogicalSlotsToBins();

    const t = new Date().toLocaleString();
    importTimeEl.textContent = `æœ€å¾ŒåŒ¯å…¥æ™‚é–“ï¼ˆ${currentWarehouse}ï¼‰ï¼š${t}`;

    slotInfoEl.textContent = `ğŸ“¥ Excel å·²åŒæ­¥ï¼š${currentWarehouse}`;
}

function parseSlotCode(str){
    if (!str) return null;
    let s = String(str).trim().toUpperCase();
    if (!s) return null;

    s = s.replace(/[^A-Z0-9]+/g, ' ');
    const parts = s.split(/\s+/).filter(Boolean);

    let rowLabel, bayStr, lvlStr;
    if (parts.length === 3){
        [rowLabel, bayStr, lvlStr] = parts;
    }else if (parts.length === 1){
        const p = parts[0];
        let m =
          p.match(/^([A-Z]+)(\d{2})(\d{2})$/) ||
          p.match(/^([A-Z]+)(\d)(\d)$/);
        if (!m) return null;
        rowLabel = m[1];
        bayStr   = m[2];
        lvlStr   = m[3];
    }else{
        return null;
    }

    const rIndex = rowLabelToIndex(rowLabel);
    if (rIndex == null || !Number.isFinite(rIndex)) return null;

    const bayNum = parseInt(bayStr, 10);
    const lvlNum = parseInt(lvlStr, 10);
    if (!Number.isFinite(bayNum) || !Number.isFinite(lvlNum)) return null;

    return {
        rIndex,
        bIndex: bayNum - 1,
        lvIndex: lvlNum - 1
    };
}

function focusBin(bin){
    if (!bin) return;

    const target = new THREE.Vector3();
    bin.hit.getWorldPosition(target);

    const dist = 6;
    camera.position.set(
        target.x + dist,
        target.y + dist,
        target.z + dist
    );

    controls.target.copy(target);
    controls.update();

    highlightedBin = bin;
    highlightEndTime = clock.getElapsedTime() + 8;

    showBinInfo(bin);
}

function handleSearch(){
    const code = ui.searchSlot.value;
    const parsed = parseSlotCode(code);
    if (!parsed){
        alert('è«‹è¼¸å…¥é¡ä¼¼ï¼šF-19-04 æˆ– F1904 çš„æ ¼å¼ã€‚');
        return;
    }
    const { rIndex, bIndex, lvIndex } = parsed;

    const bin = bins.find(
      x => x.row === rIndex && x.bay === bIndex && x.level === lvIndex
    );
    if (!bin){
        alert('æ‰¾ä¸åˆ°å°æ‡‰çš„å„²ä½ï¼ˆå¯èƒ½è¶…å‡ºç›®å‰ Row / Bay / Level ç¯„åœï¼‰ã€‚');
        return;
    }

    focusBin(bin);
}

function showBinInfo(bin){
    const rowLabel = rowIndexToLabel(bin.row);
    const bayNo    = bayIndexToNumber(bin.bay);
    const lvlNo    = levelIndexToNumber(bin.level);
    const bayStr   = pad2(bayNo);
    const lvlStr   = pad2(lvlNo);

    let html = `å„²ä½ï¼šRow <b>${rowLabel}</b>, Bay <b>${bayStr}</b>, Level <b>${lvlStr}</b><br>`;

    if (!bin.occupied){
        html += 'ç‹€æ…‹ï¼š<span class="text-emerald-300 font-semibold">ç©ºä½</span>';
    }else{
        let statusText = 'æœ‰è²¨';
        if (bin.expStatus === 'near'){
            statusText = '<span class="text-amber-300 font-semibold">åŠæœŸï¼ˆ30 å¤©å…§åˆ°æœŸï¼‰</span>';
        }else if (bin.expStatus === 'expired'){
            statusText = '<span class="text-red-400 font-semibold">å·²éæœŸ</span>';
        }else{
            statusText = '<span class="text-sky-300 font-semibold">æ­£å¸¸</span>';
        }

        html += 'ç‹€æ…‹ï¼š' + statusText;

        const meta = bin.meta || {};
        const pn   = meta['PN'] ?? '';
        const qty  = meta['æ•¸é‡'] ?? '';
        const bat  = meta['Batch'] ?? '';
        const exp  = meta['Expire Date'] ?? '';
        const mfg  = meta['Manufacture Date'] ?? '';

        html += '<br><br>--- è²¨ç‰©è³‡è¨Š ---';
        if (pn)  html += `<br>PNï¼š${pn}`;
        if (qty) html += `<br>æ•¸é‡ï¼š${qty}`;
        if (bat) html += `<br>Batchï¼š${bat}`;
        if (exp) html += `<br>Expire Dateï¼š${exp}`;
        if (mfg) html += `<br>Manufacture Dateï¼š${mfg}`;
    }

    slotInfoEl.innerHTML = html;
}

renderer.domElement.addEventListener('pointerdown', (e)=>{
    const rect = renderer.domElement.getBoundingClientRect();
    const x = ((e.clientX-rect.left)/rect.width)*2 - 1;
    const y = -((e.clientY-rect.top)/rect.height)*2 + 1;
    raycaster.setFromCamera({x,y}, camera);

    const hit = raycaster.intersectObjects(clickTargets, false)[0];
    if (hit){
        const bin = hit.object.userData.bin;
        highlightedBin = bin;
        highlightEndTime = clock.getElapsedTime() + 6;
        showBinInfo(bin);
    }
});

ui.searchBtn.addEventListener('click', handleSearch);
ui.searchSlot.addEventListener('keydown', (e)=>{
    if (e.key === 'Enter') handleSearch();
});

renderer.setAnimationLoop(() => {
    const t = clock.getElapsedTime();

    const ampNear   = 0.08;
    const speedNear = 4.0;

    const ampExpPos   = 0.45;
    const ampExpY     = 0.40;
    const speedExpPos = 15.0;

    const nowT = t;

    for (const bin of bins) {
        const lineMat  = bin.line.material;
        const cargoMat = bin.cargo.material;

        bin.cargo.position.set(bin.baseX, bin.baseY, bin.baseZ);

        let wireColor  = COLORS.wireNormal;
        let cargoColor = COLORS.cargoNormal;
        let opacity    = 0.45;

        if (bin.occupied) {
            if (bin.expStatus === 'near') {
                wireColor  = COLORS.wireNear;
                cargoColor = COLORS.cargoNear;

                bin.cargo.position.y =
                    bin.baseY + Math.sin(t * speedNear) * ampNear;

                opacity = 0.9;

            } else if (bin.expStatus === 'expired') {
                wireColor  = COLORS.wireExpired;
                cargoColor = COLORS.cargoExpired;

                const phase = (bin.row * 7 + bin.bay * 13 + bin.level * 17);

                bin.cargo.position.x =
                    bin.baseX + Math.sin(t * speedExpPos + phase) * ampExpPos;

                bin.cargo.position.z =
                    bin.baseZ + Math.cos(t * speedExpPos + phase) * ampExpPos;

                bin.cargo.position.y =
                    bin.baseY + Math.sin(t * speedExpPos * 0.7 + phase) * ampExpY;

                const flash = 0.40 + 0.45 * (0.5 + 0.5 * Math.sin(t * 12 + phase));
                opacity = flash;

            } else {
                wireColor  = COLORS.wireNormal;
                cargoColor = COLORS.cargoNormal;
                opacity = 0.7;
            }
        }

        if (bin === highlightedBin && nowT < highlightEndTime) {
            wireColor = COLORS.wireHighlight;
            opacity   = 1.0;
        }

        lineMat.color.setHex(wireColor);
        lineMat.opacity = opacity;
        cargoMat.color.setHex(cargoColor);
    }

    controls.update();
    renderer.render(scene, camera);
});

ui.rebuildBtn.addEventListener('click', rebuild);
ui.randomBtn.addEventListener('click', randomFill);
ui.syncExcelBtn.addEventListener('click', syncFromExcel);
ui.exportExcelBtn.addEventListener('click', exportToExcel);
ui.searchBtn.addEventListener('click', handleSearch);

ui.searchSlot.addEventListener('keydown', (e)=>{
    if (e.key === 'Enter') handleSearch();
});

window.addEventListener('resize', ()=>{
    const s = getSize();
    camera.aspect = s.w/s.h;
    camera.updateProjectionMatrix();
    renderer.setSize(s.w,s.h);
});

loadParamsFromStorage();
loadSlotsFromStorage();
loadImportTimeFromStorage();

rebuild();
applyLogicalSlotsToBins();
